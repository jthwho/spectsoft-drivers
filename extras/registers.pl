#!/usr/bin/perl

use Switch;

# Parse registers.info
open(REGINFO, "registers.info") || die "Couldn't open registers.info!\n";
my $level = 0;
my $line = 0;
my $regsiters;

while(<REGINFO>) {
	chomp;
	$line ++;
	# Disregard the comment lines
	if(substr($_, 0, 1) eq '#') { next };

	switch($level) {
		# This level looks for the start of the register declaration
		case 0 { 
			if(substr($_, 0, 1) eq '@') {
				$return = (($ul, $name, $cardreg, $start, $end, $rw, $type) = split(' '));
				if ($return == 7) {
					if(!isValidType($type)) {
						print "Invalid type '$type' on line $line\n";
						exit 0;
					}
					$regname = $name;
					$regtype = $type;
					$registers{$name}{'cardreg'} = $cardreg;
					$registers{$name}{'start'} = $start;
					$registers{$name}{'end'} = $end;
					if ($rw =~ /r/) {
						$registers{$name}{'readable'} = 1;
					} else {
						$registers{$name}{'readable'} = 0;
					}
					if ($rw =~ /w/) {
						$registers{$name}{'writable'} = 1;
					} else {
						$registers{$name}{'writable'} = 0;
					}
					if ($rw =~ /s/) {
						$registers{$name}{'stateful'} = 1;
					} else {
						$registers{$name}{'stateful'} = 0;
					}
					$registers{$name}{'type'} = $type;
					$level ++;
				} else {
					print "Syntax error on line $line\n";
					exit 0;
				}
			}	
		}

		# This level gets the "pretty name" for the register
		case 1 {
			$registers{$regname}{'pname'} = $_;
			if(($regtype eq 'toggle') || ($regtype eq 'value')) {
				$level = 0;
			} else {
				$level ++;
			}
		}

		# This level looks for list item (name & value pairs)
		case 2 {
			if($regtype eq 'list') {
				if($_ eq '') { $level = 0; next; }
				$return = (($kname, $kval) = split(' '));
				if($return == 2) {
					$registers{$regname}{'keys'}{$kname} = $kval;
				} else {
					print "Error with list item on line $line\n";
					exit 0;
				}
			} elsif ($regtype eq 'range') {
				$return = (($rmin, $rmax) = split(' '));
				if($return == 2) {
					$registers{$regname}{'range-min'} = $rmin;
					$registers{$regname}{'range-max'} = $rmax;
					$level = 0;
				} else {
					print "Error with range values on line $line\n";
					exit 0;
				}
			}
		}
	}
	
}

# Now write the header file
if ($ARGV[0] eq 'header') {
	writeHeader();
} elsif($ARGV[0] eq 'strings') {
	writeRegStrings();
}
exit 0;

sub isValidType {
	$type = shift;
	if ($type eq 'list') { return 1; }
	if ($type eq 'toggle') { return 1; };
	if ($type eq 'value') { return 1; };
	if ($type eq 'range') { return 1; };
	return 0;
}

sub writeHeader {
	print "/* AJA CARD REGISTERS \n";
	print " * THIS FILE IS AUTOMATICALY GENERATED BY THE SPECTSOFT AJA-DRIVER PACKAGE */\n\n\n";
	print "#ifndef _AJA_REGISTERS_H_\n";
	print "#define _AJA_REGISTERS_H_\n\n\n";

	print "#ifndef __KERNEL__\n";
	print "#include <stdint.h>\n";
	print "#endif\n\n";

	print "typedef struct {\n";
	print "\tuint32_t add;\n";
	print "\tuint32_t shift;\n";
	print "\tuint32_t mask;\n";
	print "} aja_register_t;\n";
	print "\n\n\n";
	
	foreach $name (sort keys %registers) {
		$pname = $registers{$name}{'pname'};
		$reg = $registers{$name}{'cardreg'};
		$start = $registers{$name}{'start'};
		$end = $registers{$name}{'end'};
		$type = $registers{$name}{'type'};
		$rw = $registers{$name}{'readable'} + ($registers{$name}{'writable'} * 2);
		switch ($rw) {
			case 0 { $rw = "Not Accessable!"; };
			case 1 { $rw = "Read Only"; };
			case 2 { $rw = "Write Only"; };
			case 3 { $rw = "Read/Write"; };
		}
		
		$mask = 0;
		for($i = $start; $i <= $end; $i++) {
			$mask += (1 << $i);
		}
		print "/* $pname (Reg $reg, bits $start to $end) [$rw] */\n";
		if($type eq 'list') {
			print "/* __ Settings __";
			foreach $kname (sort keys %{$registers{$name}{'keys'}}) {
				$kvalue = $registers{$name}{'keys'}{$kname};
				print "\n * $kvalue: $kname";
			}
			print " */\n";
		}
		printf("const aja_register_t ajareg_$name = {0x%Xu, %du, 0x%08Xu};\n\n\n", $reg * 4, $start, $mask);
		
	}

	print "\n#endif /* _AJA_REGISTERS_H_ defined */\n\n";
}


sub writeRegStrings {
	print "/* AJA CARD REGISTER STRINGS STRUCTURE \n";
	print " * THIS FILE IS AUTOMATICALY GENERATED BY THE SPECTSOFT AJA-DRIVER PACKAGE */\n\n\n";
	print "#ifndef _AJA_REGSTRINGS_H_\n";
	print "#define _AJA_REGSTRINGS_H_\n\n\n";

	print "#include <aja_registers.h>\n\n";

	foreach $name (sort keys %registers) {
		$pname = $registers{$name}{'pname'};
		$reg = $registers{$name}{'cardreg'};
		$start = $registers{$name}{'start'};
		$end = $registers{$name}{'end'};
		$type = $registers{$name}{'type'};
		
		print "static const aja_regoption_t regopt_${name}[] = {\n";
		if($type eq 'list') {
			foreach $kname (sort keys %{$registers{$name}{'keys'}}) {
				$kvalue = $registers{$name}{'keys'}{$kname};
				print "\t{\"$kname\", $kvalue},\n"
			}
		}
		print "\t{NULL, 0}\n";
		print "};\n\n";
		
	}
	
	print "static const aja_regstring_t regstring[] = {\n";

	foreach $name (sort keys %registers) {
		$pname = $registers{$name}{'pname'};
		$type = $registers{$name}{'type'};
		$flags = $registers{$name}{'readable'} + 
			($registers{$name}{'writable'} * 2) +
			($registers{$name}{'stateful'} * 4);
		
		printf("\t{\"$name\", \"$pname\", (const aja_register_t *)&ajareg_$name, (const aja_regoption_t *)&regopt_$name, 0x%X},\n", $flags);
		
	}

	print "\t{NULL, NULL, NULL, NULL, 0}\n";
	print "};\n\n";

	print "\n#endif /* _AJA_REGSTRINGS_H_ defined */\n\n";
}

